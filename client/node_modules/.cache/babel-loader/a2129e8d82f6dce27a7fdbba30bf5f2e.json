{"ast":null,"code":"/*\nCopyright (c) 2019-present NAVER Corp.\nname: @egjs/flicking-plugins\nlicense: MIT <https://github.com/naver/egjs-flicking-plugins>\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-flicking-plugins\nversion: 3.3.0\n*/\n\n/**\n * You can apply parallax effect while panel is moving.\n * @ko 패널들을 움직이면서 parallax 효과를 부여할 수 있습니다.\n * @memberof eg.Flicking.plugins\n */\nvar Parallax = /*#__PURE__*/function () {\n  /**\n   * @param - Selector of the element to apply parallax effect <ko> Parallax 효과를 적용할 엘리먼트의 선택자 </ko>\n   * @param - Effect amplication scale <ko>효과 증폭도</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.Parallax(\"img\", 1));\n   */\n  function Parallax(selector, scale) {\n    if (selector === void 0) {\n      selector = \"\";\n    }\n\n    if (scale === void 0) {\n      scale = 1;\n    }\n\n    var _this = this;\n\n    this.selector = selector;\n    this.scale = scale;\n\n    this.onMove = function (e) {\n      _this.move(e.currentTarget);\n    };\n  }\n\n  var __proto = Parallax.prototype;\n\n  __proto.init = function (flicking) {\n    flicking.on(\"move\", this.onMove);\n    this.move(flicking);\n  };\n\n  __proto.update = function (flicking) {\n    this.move(flicking);\n  };\n\n  __proto.destroy = function (flicking) {\n    flicking.off(\"move\", this.onMove);\n  };\n\n  __proto.move = function (flicking) {\n    var _this = this;\n\n    var panels = flicking.getVisiblePanels();\n    panels.forEach(function (panel) {\n      var progress = panel.getOutsetProgress();\n      var el = panel.getElement();\n      var target = el.querySelector(_this.selector);\n      var parentTarget = target.parentNode;\n      var rect = target.getBoundingClientRect();\n      var parentRect = parentTarget.getBoundingClientRect();\n      var position = (parentRect.width - rect.width) / 2 * progress * _this.scale;\n      var transform = \"translate(-50%) translate(\" + position + \"px)\";\n      var style = target.style;\n      style.cssText += \"transform: \" + transform + \";-webkit-transform: \" + transform + \";-ms-transform:\" + transform;\n    });\n  };\n\n  return Parallax;\n}();\n/**\n * You can apply fade in / out effect while panel is moving.\n * @ko 패널들을 움직이면서 fade in / out 효과를 부여할 수 있습니다.\n * @memberof eg.Flicking.plugins\n */\n\n\nvar Fade = /*#__PURE__*/function () {\n  /**\n   * @param - The selector of the element to which the fade effect is to be applied. If the selector is blank, it applies to panel element. <ko>Fade 효과를 적용할 대상의 선택자. 선택자가 공백이면 패널 엘리먼트에 적용된다.</ko>\n   * @param - Effect amplication scale <ko>효과 증폭도</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.Fade(\"p\", 1));\n   */\n  function Fade(selector, scale) {\n    if (selector === void 0) {\n      selector = \"\";\n    }\n\n    if (scale === void 0) {\n      scale = 1;\n    }\n\n    var _this = this;\n\n    this.selector = selector;\n    this.scale = scale;\n\n    this.onMove = function (e) {\n      _this.move(e.currentTarget);\n    };\n  }\n\n  var __proto = Fade.prototype;\n\n  __proto.init = function (flicking) {\n    flicking.on(\"move\", this.onMove);\n    this.move(flicking);\n  };\n\n  __proto.update = function (flicking) {\n    this.move(flicking);\n  };\n\n  __proto.destroy = function (flicking) {\n    flicking.off(\"move\", this.onMove);\n  };\n\n  __proto.move = function (flicking) {\n    var panels = flicking.getVisiblePanels();\n    var selector = this.selector;\n    var scale = this.scale;\n    panels.forEach(function (panel) {\n      var progress = panel.getOutsetProgress();\n      var el = panel.getElement();\n      var target = selector ? el.querySelector(selector) : el;\n      var opacity = Math.min(1, Math.max(0, 1 - Math.abs(progress * scale)));\n      target.style.opacity = \"\" + opacity;\n    });\n  };\n\n  return Fade;\n}();\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\n\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar DEFAULT_OPTION = {\n  duration: 2000,\n  direction: \"NEXT\",\n  stopOnHover: false\n};\n/**\n * Plugin that allow you to automatically move to the next/previous panel, on a specific time basis\n * @ko 일정 시간마다, 자동으로 다음/이전 패널로 넘어가도록 할 수 있는 플러그인\n * @memberof eg.Flicking.plugins\n */\n\nvar AutoPlay = /*#__PURE__*/function () {\n  /**\n   * @param options Options for the AutoPlay instance.<ko>AutoPlay 옵션</ko>\n   * @param options.duration Time to wait before moving on to the next panel.<ko>다음 패널로 움직이기까지 대기 시간</ko>\n   * @param options.direction The direction in which the panel moves.<ko>패널이 움직이는 방향</ko>\n   * @param options.stopOnHover Whether to stop when mouse hover upon the element.<ko>엘리먼트에 마우스를 올렸을 때 AutoPlay를 정지할지 여부</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.AutoPlay(2000, \"NEXT\"));\n   */\n  function AutoPlay(options, direction) {\n    if (options === void 0) {\n      options = DEFAULT_OPTION;\n    }\n\n    if (direction === void 0) {\n      direction = DEFAULT_OPTION.direction;\n    }\n\n    var _this = this;\n    /* Internal Values */\n\n\n    this.flicking = null;\n    this.timerId = 0;\n    this.mouseEntered = false;\n\n    this.play = function () {\n      var flicking = _this.flicking;\n      if (!flicking) return;\n\n      _this.stop();\n\n      if (_this.mouseEntered || flicking.isPlaying()) return;\n      _this.timerId = window.setTimeout(function () {\n        flicking[_this.direction === \"NEXT\" ? \"next\" : \"prev\"]();\n\n        _this.play();\n      }, _this.duration);\n    };\n\n    this.stop = function () {\n      clearTimeout(_this.timerId);\n    };\n\n    this.onMouseEnter = function () {\n      _this.mouseEntered = true;\n\n      _this.stop();\n    };\n\n    this.onMouseLeave = function () {\n      _this.mouseEntered = false;\n\n      _this.play();\n    };\n\n    if (typeof options === \"number\") {\n      // Fallback for previous interface\n      this.duration = options;\n      this.direction = direction;\n      this.stopOnHover = DEFAULT_OPTION.stopOnHover;\n      return;\n    }\n\n    var mergedOptions = __assign({}, DEFAULT_OPTION, options);\n\n    var duration = mergedOptions.duration,\n        dir = mergedOptions.direction,\n        stopOnHover = mergedOptions.stopOnHover;\n    this.duration = duration;\n    this.direction = dir;\n    this.stopOnHover = stopOnHover;\n  }\n\n  var __proto = AutoPlay.prototype;\n\n  __proto.init = function (flicking) {\n    flicking.on({\n      moveStart: this.stop,\n      holdStart: this.stop,\n      moveEnd: this.play,\n      select: this.play\n    });\n    this.flicking = flicking;\n\n    if (this.stopOnHover) {\n      var targetEl = this.flicking.getElement();\n      targetEl.addEventListener(\"mouseenter\", this.onMouseEnter, false);\n      targetEl.addEventListener(\"mouseleave\", this.onMouseLeave, false);\n    }\n\n    this.play();\n  };\n\n  __proto.destroy = function () {\n    var flicking = this.flicking;\n    this.mouseEntered = false;\n    this.stop();\n    if (!flicking) return;\n    flicking.off(\"moveStart\", this.stop);\n    flicking.off(\"holdStart\", this.stop);\n    flicking.off(\"moveEnd\", this.play);\n    flicking.off(\"select\", this.play);\n    var targetEl = flicking.getElement();\n    targetEl.removeEventListener(\"mouseenter\", this.onMouseEnter, false);\n    targetEl.removeEventListener(\"mouseleave\", this.onMouseLeave, false);\n    this.flicking = null;\n  };\n\n  return AutoPlay;\n}();\n/**\n * @namepsace eg.Flicking\n */\n\n\nexport { AutoPlay, Fade, Parallax };","map":{"version":3,"sources":["../src/Parallax.ts","../src/Fade.ts","../src/AutoPlay.ts","../src/index.ts"],"names":["selector","scale","flicking","_this","e","panels","progress","panel","el","target","parentTarget","rect","parentRect","position","transform","style","opacity","Math","DEFAULT_OPTION","duration","direction","stopOnHover","options","mergedOptions","tslib_1","dir","moveStart","holdStart","moveEnd","select","play","targetEl","clearTimeout"],"mappings":"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","sourcesContent":["import Flicking, { FlickingEvent, Plugin } from \"@egjs/flicking\";\n\n/**\n * You can apply parallax effect while panel is moving.\n * @ko 패널들을 움직이면서 parallax 효과를 부여할 수 있습니다.\n * @memberof eg.Flicking.plugins\n */\nclass Parallax implements Plugin {\n  /**\n   * @param - Selector of the element to apply parallax effect <ko> Parallax 효과를 적용할 엘리먼트의 선택자 </ko>\n   * @param - Effect amplication scale <ko>효과 증폭도</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.Parallax(\"img\", 1));\n   */\n  constructor(private selector: string = \"\", private scale: number = 1) {}\n  public init(flicking: Flicking): void {\n    flicking.on(\"move\", this.onMove);\n    this.move(flicking);\n  }\n  public update(flicking: Flicking): void {\n    this.move(flicking);\n  }\n  public destroy(flicking: Flicking): void {\n    flicking.off(\"move\", this.onMove);\n  }\n  private onMove = (e: FlickingEvent): void => {\n    this.move(e.currentTarget);\n  }\n  private move(flicking: Flicking): void {\n    const panels = flicking.getVisiblePanels();\n\n    panels.forEach(panel => {\n      const progress = panel.getOutsetProgress();\n      const el = panel.getElement();\n      const target = el.querySelector<HTMLElement>(this.selector)!;\n      const parentTarget = target.parentNode as Element;\n      const rect = target.getBoundingClientRect();\n      const parentRect = parentTarget.getBoundingClientRect();\n      const position = (parentRect.width - rect.width) / 2 * progress * this.scale;\n      const transform = `translate(-50%) translate(${position}px)`;\n      const style = target.style;\n\n      style.cssText += `transform: ${transform};-webkit-transform: ${transform};-ms-transform:${transform}`;\n    });\n  }\n}\nexport default Parallax;\n","import Flicking, { FlickingEvent, Plugin } from \"@egjs/flicking\";\n\n/**\n * You can apply fade in / out effect while panel is moving.\n * @ko 패널들을 움직이면서 fade in / out 효과를 부여할 수 있습니다.\n * @memberof eg.Flicking.plugins\n */\nclass Fade implements Plugin {\n  /**\n   * @param - The selector of the element to which the fade effect is to be applied. If the selector is blank, it applies to panel element. <ko>Fade 효과를 적용할 대상의 선택자. 선택자가 공백이면 패널 엘리먼트에 적용된다.</ko>\n   * @param - Effect amplication scale <ko>효과 증폭도</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.Fade(\"p\", 1));\n   */\n  constructor(private selector: string = \"\", private scale: number = 1) {}\n  public init(flicking: Flicking): void {\n    flicking.on(\"move\", this.onMove);\n    this.move(flicking);\n  }\n  public update(flicking: Flicking): void {\n    this.move(flicking);\n  }\n  public destroy(flicking: Flicking): void {\n    flicking.off(\"move\", this.onMove);\n  }\n  private onMove = (e: FlickingEvent): void => {\n    this.move(e.currentTarget);\n  }\n  private move(flicking: Flicking): void {\n    const panels = flicking.getVisiblePanels();\n    const selector = this.selector;\n    const scale = this.scale;\n\n    panels.forEach(panel => {\n      const progress = panel.getOutsetProgress();\n      const el = panel.getElement();\n      const target = selector ? el.querySelector<HTMLElement>(selector)! : el;\n      const opacity = Math.min(1, Math.max(0, (1 - Math.abs(progress * scale))));\n\n      target.style.opacity = `${opacity}`;\n    });\n  }\n}\n\nexport default Fade;\n","import Flicking, { FlickingEvent, Plugin, Direction } from \"@egjs/flicking\";\n\ninterface AutoPlayOptions {\n  duration: number;\n  direction: Direction[keyof Direction];\n  stopOnHover: boolean;\n}\n\n// tslint:disable-next-line naming-convention\nconst DEFAULT_OPTION: AutoPlayOptions = {\n  duration: 2000,\n  direction: \"NEXT\",\n  stopOnHover: false,\n};\n\n/**\n * Plugin that allow you to automatically move to the next/previous panel, on a specific time basis\n * @ko 일정 시간마다, 자동으로 다음/이전 패널로 넘어가도록 할 수 있는 플러그인\n * @memberof eg.Flicking.plugins\n */\nclass AutoPlay implements Plugin {\n  /* Options */\n  private duration: AutoPlayOptions[\"duration\"];\n  private direction: AutoPlayOptions[\"direction\"];\n  private stopOnHover: AutoPlayOptions[\"stopOnHover\"];\n\n  /* Internal Values */\n  private flicking: Flicking | null = null;\n  private timerId = 0;\n  private mouseEntered = false;\n\n  /**\n   * @param options Options for the AutoPlay instance.<ko>AutoPlay 옵션</ko>\n   * @param options.duration Time to wait before moving on to the next panel.<ko>다음 패널로 움직이기까지 대기 시간</ko>\n   * @param options.direction The direction in which the panel moves.<ko>패널이 움직이는 방향</ko>\n   * @param options.stopOnHover Whether to stop when mouse hover upon the element.<ko>엘리먼트에 마우스를 올렸을 때 AutoPlay를 정지할지 여부</ko>\n   * @example\n   * flicking.addPlugins(new eg.Flicking.plugins.AutoPlay(2000, \"NEXT\"));\n   */\n  constructor(options: Partial<AutoPlayOptions> = DEFAULT_OPTION, direction: AutoPlayOptions[\"direction\"] = DEFAULT_OPTION.direction) {\n    if (typeof options === \"number\") {\n      // Fallback for previous interface\n      this.duration = options as number;\n      this.direction = direction;\n      this.stopOnHover = DEFAULT_OPTION.stopOnHover;\n      return;\n    }\n\n    const mergedOptions = {\n      ...DEFAULT_OPTION,\n      ...options,\n    } as AutoPlayOptions;\n    const { duration, direction: dir, stopOnHover } = mergedOptions;\n\n    this.duration = duration;\n    this.direction = dir;\n    this.stopOnHover = stopOnHover;\n  }\n\n  public init(flicking: Flicking): void {\n    flicking.on({\n      moveStart: this.stop,\n      holdStart: this.stop,\n      moveEnd: this.play,\n      select: this.play,\n    });\n\n    this.flicking = flicking;\n    if (this.stopOnHover) {\n      const targetEl = this.flicking.getElement();\n      targetEl.addEventListener(\"mouseenter\", this.onMouseEnter, false);\n      targetEl.addEventListener(\"mouseleave\", this.onMouseLeave, false);\n    }\n\n    this.play();\n  }\n\n  public destroy(): void {\n    const flicking = this.flicking;\n    this.mouseEntered = false;\n    this.stop();\n\n    if (!flicking) return;\n\n    flicking.off(\"moveStart\", this.stop);\n    flicking.off(\"holdStart\", this.stop);\n    flicking.off(\"moveEnd\", this.play);\n    flicking.off(\"select\", this.play);\n\n    const targetEl = flicking.getElement();\n    targetEl.removeEventListener(\"mouseenter\", this.onMouseEnter, false);\n    targetEl.removeEventListener(\"mouseleave\", this.onMouseLeave, false);\n\n    this.flicking = null;\n  }\n\n  public play = () => {\n    const flicking = this.flicking;\n    if (!flicking) return;\n\n    this.stop();\n\n    if (this.mouseEntered || flicking.isPlaying()) return;\n\n    this.timerId = window.setTimeout(() => {\n      flicking[this.direction === \"NEXT\" ? \"next\" : \"prev\"]();\n\n      this.play();\n    }, this.duration);\n  }\n\n  public stop = () => {\n    clearTimeout(this.timerId);\n  }\n\n  private onMouseEnter = () => {\n    this.mouseEntered = true;\n    this.stop();\n  }\n\n  private onMouseLeave = () => {\n    this.mouseEntered = false;\n    this.play();\n  }\n}\n\nexport default AutoPlay;\n","/**\n * @namepsace eg.Flicking\n */\n/**\n * @namepsace eg.Flicking.plugins\n */\nimport Parallax from \"./Parallax\";\nimport Fade from \"./Fade\";\nimport AutoPlay from \"./AutoPlay\";\n\nexport {\n  Parallax,\n  Fade,\n  AutoPlay,\n};\n"]},"metadata":{},"sourceType":"module"}